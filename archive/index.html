<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Retro Dither Prototype</title>
    <style>
      html, body { margin: 0; height: 100%; background: #000; overflow: hidden; }
      canvas { display: block; image-rendering: pixelated; }
      .hint {
        position: fixed; left: 12px; bottom: 12px;
        font: 12px/1.4 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        color: rgba(255,255,255,0.65);
        user-select: none;
      }
    </style>
  </head>
  <body>
    <div class="hint">Drag to orbit. Wheel to zoom.</div>

    <script type="module">
      import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
      import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";
      import { EffectComposer } from "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js";
      import { RenderPass } from "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js";
      import { ShaderPass } from "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/ShaderPass.js";

      // ---------- Renderer ----------
      const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 0.8;
      document.body.appendChild(renderer.domElement);

      // ---------- Scene ----------
      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x05070a, 0.065);

      // Subtle gloomy background
      scene.background = new THREE.Color(0x05070a);

      // ---------- Camera (45° over plane) ----------
      const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
      // 45° pitch down + 45° yaw "iso-ish"
      const r = 9.0;
      const pitch = THREE.MathUtils.degToRad(45);
      const yaw = THREE.MathUtils.degToRad(45);
      camera.position.set(
        r * Math.cos(pitch) * Math.cos(yaw),
        r * Math.sin(pitch),
        r * Math.cos(pitch) * Math.sin(yaw)
      );
      camera.lookAt(0, 0, 0);

      // ---------- Controls ----------
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.target.set(0, 0, 0);
      controls.minDistance = 4;
      controls.maxDistance = 18;
      controls.maxPolarAngle = THREE.MathUtils.degToRad(80);

      // ---------- Lights (dim / moody) ----------
      scene.add(new THREE.AmbientLight(0x223344, 0.25));

      const key = new THREE.DirectionalLight(0xaabbd0, 0.55);
      key.position.set(3, 6, 2);
      key.castShadow = false;
      scene.add(key);

      const rim = new THREE.DirectionalLight(0x445566, 0.25);
      rim.position.set(-5, 2, -6);
      scene.add(rim);

      // ---------- Ground plane ----------
      const planeGeo = new THREE.PlaneGeometry(30, 30, 1, 1);
      const planeMat = new THREE.MeshStandardMaterial({
        color: 0x0b1117,
        roughness: 0.98,
        metalness: 0.02
      });
      const plane = new THREE.Mesh(planeGeo, planeMat);
      plane.rotation.x = -Math.PI / 2;
      plane.position.y = -1.2;
      scene.add(plane);

      // Slight grid-ish lines (subtle)
      const grid = new THREE.GridHelper(30, 30, 0x0f1a22, 0x0a121a);
      grid.position.y = -1.19;
      grid.material.opacity = 0.35;
      grid.material.transparent = true;
      scene.add(grid);

      // ---------- Objects ----------
      const sphere = new THREE.Mesh(
        new THREE.SphereGeometry(1.1, 24, 16),
        new THREE.MeshStandardMaterial({
          color: 0x2a3a44,
          roughness: 0.65,
          metalness: 0.15
        })
      );
      sphere.position.set(-1.8, -0.2, 0.3);
      scene.add(sphere);

      // "Diamond" = Octahedron reads like a gem/diamond
      const diamond = new THREE.Mesh(
        new THREE.OctahedronGeometry(1.0, 0),
        new THREE.MeshStandardMaterial({
          color: 0x3a2f3f,
          roughness: 0.35,
          metalness: 0.25,
          emissive: 0x050006,
          emissiveIntensity: 0.35
        })
      );
      diamond.position.set(1.8, -0.2, -0.6);
      scene.add(diamond);

      // ---------- Post: Pixelate + Ordered Dither ----------
      // We render at a low internal resolution then upscale (pixelation).
      // Then apply an ordered Bayer dither to push that retro gritty feel.
      const DitherPixelShader = {
        uniforms: {
          tDiffuse: { value: null },
          resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
          pixelSize: { value: 3.0 }, // larger = chunkier pixels
          ditherStrength: { value: 0.85 }, // more = heavier dithering
          gloom: { value: 0.12 }, // darken overall
          contrast: { value: 1.15 }
        },
        vertexShader: /* glsl */`
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: /* glsl */`
          uniform sampler2D tDiffuse;
          uniform vec2 resolution;
          uniform float pixelSize;
          uniform float ditherStrength;
          uniform float gloom;
          uniform float contrast;
          varying vec2 vUv;

          // 4x4 Bayer matrix threshold (0..1)
          float bayer4(vec2 p) {
            // pixel coords mod 4
            int x = int(mod(p.x, 4.0));
            int y = int(mod(p.y, 4.0));
            int index = x + y * 4;

            // Values 0..15
            int m[16];
            m[0]=0;  m[1]=8;  m[2]=2;  m[3]=10;
            m[4]=12; m[5]=4;  m[6]=14; m[7]=6;
            m[8]=3;  m[9]=11; m[10]=1; m[11]=9;
            m[12]=15;m[13]=7; m[14]=13;m[15]=5;

            return (float(m[index]) + 0.5) / 16.0;
          }

          vec3 applyContrast(vec3 c, float k) {
            return (c - 0.5) * k + 0.5;
          }

          void main() {
            // Pixelation: snap uv to a pixel grid
            vec2 fragCoord = vUv * resolution;
            vec2 snapped = floor(fragCoord / pixelSize) * pixelSize;
            vec2 uv2 = (snapped + 0.5) / resolution;

            vec3 col = texture2D(tDiffuse, uv2).rgb;

            // Gloom: darken and slight contrast
            col = applyContrast(col, contrast);
            col *= (1.0 - gloom);

            // Luma for dithering decision
            float luma = dot(col, vec3(0.299, 0.587, 0.114));

            // Ordered threshold
            float t = bayer4(snapped / pixelSize);

            // Quantize (posterize) + dither push
            // 6 levels per channel (you can reduce for harsher retro)
            float levels = 6.0;
            vec3 q = floor(col * levels + (t - 0.5) * ditherStrength) / levels;

            gl_FragColor = vec4(clamp(q, 0.0, 1.0), 1.0);
          }
        `
      };

      const composer = new EffectComposer(renderer);
      composer.addPass(new RenderPass(scene, camera));

      const ditherPass = new ShaderPass(DitherPixelShader);
      composer.addPass(ditherPass);

      // ---------- Animate ----------
      const clock = new THREE.Clock();

      function animate() {
        requestAnimationFrame(animate);
        const t = clock.getElapsedTime();

        controls.update();

        // subtle motion for vibe
        sphere.rotation.y = t * 0.35;
        diamond.rotation.y = -t * 0.55;
        diamond.rotation.x = t * 0.25;

        composer.render();
      }
      animate();

      // ---------- Resize ----------
      window.addEventListener("resize", () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        composer.setSize(window.innerWidth, window.innerHeight);
        ditherPass.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
